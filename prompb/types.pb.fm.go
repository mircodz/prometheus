// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package prompb

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for MetricMetadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *MetricMetadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Type (enum,optional)
	if m.Type != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Type))
	}
	// MetricFamilyName (string,optional)
	if l = len(m.MetricFamilyName); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Help (string,optional)
	if l = len(m.Help); l > 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Unit (string,optional)
	if l = len(m.Unit); l > 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *MetricMetadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *MetricMetadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Type (1,enum,optional)
	if m.Type != 0 {
		enc.EncodeInt32(1, int32(m.Type))
	}
	// MetricFamilyName (2,string,optional)
	if len(m.MetricFamilyName) > 0 {
		enc.EncodeString(2, m.MetricFamilyName)
	}
	// Help (4,string,optional)
	if len(m.Help) > 0 {
		enc.EncodeString(4, m.Help)
	}
	// Unit (5,string,optional)
	if len(m.Unit) > 0 {
		enc.EncodeString(5, m.Unit)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *MetricMetadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=1): %w", err)
			} else {
				m.Type = MetricMetadata_MetricType(v)
			}
		case 2: // MetricFamilyName (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'metric_family_name' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'metric_family_name' (tag=2): %w", err)
			} else {
				m.MetricFamilyName = s
			}

		case 4: // Help (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'help' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'help' (tag=4): %w", err)
			} else {
				m.Help = s
			}

		case 5: // Unit (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'unit' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'unit' (tag=5): %w", err)
			} else {
				m.Unit = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Sample

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Sample) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Value (double,optional)
	if m.Value != 0 {
		sz += csproto.SizeOfTagKey(1) + 8
	}
	// Timestamp (int64,optional)
	if m.Timestamp != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Timestamp))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Sample) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Sample) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Value (1,double,optional)
	if m.Value != 0 {
		enc.EncodeFloat64(1, m.Value)
	}
	// Timestamp (2,int64,optional)
	if m.Timestamp != 0 {
		enc.EncodeInt64(2, m.Timestamp)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Sample) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Value (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'value' (tag=1), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'value' (tag=1): %w", err)
			} else {
				m.Value = v
			}
		case 2: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=2): %w", err)
			} else {
				m.Timestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Exemplar

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Exemplar) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Labels (message,repeated)
	for _, val := range m.Labels {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Value (double,optional)
	if m.Value != 0 {
		sz += csproto.SizeOfTagKey(2) + 8
	}
	// Timestamp (int64,optional)
	if m.Timestamp != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.Timestamp))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Exemplar) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Exemplar) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Labels (1,message,repeated)
	for _, mm := range m.Labels {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'labels' (tag=1): %w", err)
		}
	}
	// Value (2,double,optional)
	if m.Value != 0 {
		enc.EncodeFloat64(2, m.Value)
	}
	// Timestamp (3,int64,optional)
	if m.Timestamp != 0 {
		enc.EncodeInt64(3, m.Timestamp)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Exemplar) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Labels (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'labels' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm Label
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'labels' (tag=1): %w", err)
			}
			m.Labels = append(m.Labels, &mm)
		case 2: // Value (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'value' (tag=2), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'value' (tag=2): %w", err)
			} else {
				m.Value = v
			}
		case 3: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=3): %w", err)
			} else {
				m.Timestamp = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Histogram

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Histogram) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Sum (double,optional)
	if m.Sum != 0 {
		sz += csproto.SizeOfTagKey(3) + 8
	}
	// Schema (sint32,optional)
	if m.Schema != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfZigZag(uint64(m.Schema))
	}
	// ZeroThreshold (double,optional)
	if m.ZeroThreshold != 0 {
		sz += csproto.SizeOfTagKey(5) + 8
	}
	// NegativeSpans (message,repeated)
	for _, val := range m.NegativeSpans {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// NegativeDeltas (sint64,repeated,packed)
	if len(m.NegativeDeltas) > 0 {
		sz += csproto.SizeOfTagKey(9)
		l = 0
		for _, iv := range m.NegativeDeltas {
			l += csproto.SizeOfZigZag(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// NegativeCounts (double,repeated,packed)
	if l = len(m.NegativeCounts); l > 0 {
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// PositiveSpans (message,repeated)
	for _, val := range m.PositiveSpans {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// PositiveDeltas (sint64,repeated,packed)
	if len(m.PositiveDeltas) > 0 {
		sz += csproto.SizeOfTagKey(12)
		l = 0
		for _, iv := range m.PositiveDeltas {
			l += csproto.SizeOfZigZag(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// PositiveCounts (double,repeated,packed)
	if l = len(m.PositiveCounts); l > 0 {
		sz += csproto.SizeOfTagKey(13) + csproto.SizeOfVarint(uint64(l)) + (l * 8)
	}
	// ResetHint (enum,optional)
	if m.ResetHint != 0 {
		sz += csproto.SizeOfTagKey(14) + csproto.SizeOfVarint(uint64(m.ResetHint))
	}
	// Timestamp (int64,optional)
	if m.Timestamp != 0 {
		sz += csproto.SizeOfTagKey(15) + csproto.SizeOfVarint(uint64(m.Timestamp))
	}

	// Count (oneof)
	if m.Count != nil {
		switch typedVal := m.Count.(type) {
		case *Histogram_CountInt: // count_int (1,uint64)
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(typedVal.CountInt))
		case *Histogram_CountFloat: // count_float (2,double)
			sz += csproto.SizeOfTagKey(2) + 8
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// ZeroCount (oneof)
	if m.ZeroCount != nil {
		switch typedVal := m.ZeroCount.(type) {
		case *Histogram_ZeroCountInt: // zero_count_int (6,uint64)
			sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(typedVal.ZeroCountInt))
		case *Histogram_ZeroCountFloat: // zero_count_float (7,double)
			sz += csproto.SizeOfTagKey(7) + 8
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Histogram) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Histogram) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Sum (3,double,optional)
	if m.Sum != 0 {
		enc.EncodeFloat64(3, m.Sum)
	}
	// Schema (4,sint32,optional)
	if m.Schema != 0 {
		enc.EncodeSInt32(4, m.Schema)
	}
	// ZeroThreshold (5,double,optional)
	if m.ZeroThreshold != 0 {
		enc.EncodeFloat64(5, m.ZeroThreshold)
	}
	// NegativeSpans (8,message,repeated)
	for _, mm := range m.NegativeSpans {
		if err = enc.EncodeNested(8, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'negative_spans' (tag=8): %w", err)
		}
	}
	// NegativeDeltas (9,sint64,repeated,packed)
	if len(m.NegativeDeltas) > 0 {
		enc.EncodePackedSInt64(9, m.NegativeDeltas)
	}
	// NegativeCounts (10,double,repeated,packed)
	if len(m.NegativeCounts) > 0 {
		enc.EncodePackedFloat64(10, m.NegativeCounts)
	}
	// PositiveSpans (11,message,repeated)
	for _, mm := range m.PositiveSpans {
		if err = enc.EncodeNested(11, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'positive_spans' (tag=11): %w", err)
		}
	}
	// PositiveDeltas (12,sint64,repeated,packed)
	if len(m.PositiveDeltas) > 0 {
		enc.EncodePackedSInt64(12, m.PositiveDeltas)
	}
	// PositiveCounts (13,double,repeated,packed)
	if len(m.PositiveCounts) > 0 {
		enc.EncodePackedFloat64(13, m.PositiveCounts)
	}
	// ResetHint (14,enum,optional)
	if m.ResetHint != 0 {
		enc.EncodeInt32(14, int32(m.ResetHint))
	}
	// Timestamp (15,int64,optional)
	if m.Timestamp != 0 {
		enc.EncodeInt64(15, m.Timestamp)
	}
	// Count (oneof)

	if m.Count != nil {
		switch typedVal := m.Count.(type) {
		case *Histogram_CountInt: // count_int (1,uint64)
			enc.EncodeUInt64(1, typedVal.CountInt)
		case *Histogram_CountFloat: // count_float (2,double)
			enc.EncodeFloat64(2, typedVal.CountFloat)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// ZeroCount (oneof)

	if m.ZeroCount != nil {
		switch typedVal := m.ZeroCount.(type) {
		case *Histogram_ZeroCountInt: // zero_count_int (6,uint64)
			enc.EncodeUInt64(6, typedVal.ZeroCountInt)
		case *Histogram_ZeroCountFloat: // zero_count_float (7,double)
			enc.EncodeFloat64(7, typedVal.ZeroCountFloat)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Histogram) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {

		case 3: // Sum (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'sum' (tag=3), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'sum' (tag=3): %w", err)
			} else {
				m.Sum = v
			}
		case 4: // Schema (sint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'schema' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeSInt32(); err != nil {
				return fmt.Errorf("unable to decode sint32 value for field 'schema' (tag=4): %w", err)
			} else {
				m.Schema = v
			}
		case 5: // ZeroThreshold (double,optional)
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'zero_threshold' (tag=5), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'zero_threshold' (tag=5): %w", err)
			} else {
				m.ZeroThreshold = v
			}

		case 8: // NegativeSpans (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'negative_spans' (tag=8), expected 2 (length-delimited)", wt)
			}
			var mm BucketSpan
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'negative_spans' (tag=8): %w", err)
			}
			m.NegativeSpans = append(m.NegativeSpans, &mm)
		case 9: // NegativeDeltas (sint64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeSInt64(); err != nil {
					return fmt.Errorf("unable to decode sint64 value for field 'negative_deltas' (tag=9): %w", err)
				} else {
					m.NegativeDeltas = append(m.NegativeDeltas, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedSint64(); err != nil {
					return fmt.Errorf("unable to decode packed sint64 values for field 'negative_deltas' (tag=9): %w", err)
				} else {
					m.NegativeDeltas = append(m.NegativeDeltas, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'negative_deltas' (tag=9), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 10: // NegativeCounts (double,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFloat64(); err != nil {
					return fmt.Errorf("unable to decode double value for field 'negative_counts' (tag=10): %w", err)
				} else {
					m.NegativeCounts = append(m.NegativeCounts, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat64(); err != nil {
					return fmt.Errorf("unable to decode packed double values for field 'negative_counts' (tag=10): %w", err)
				} else {
					m.NegativeCounts = append(m.NegativeCounts, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'negative_counts' (tag=10), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}
		case 11: // PositiveSpans (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'positive_spans' (tag=11), expected 2 (length-delimited)", wt)
			}
			var mm BucketSpan
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'positive_spans' (tag=11): %w", err)
			}
			m.PositiveSpans = append(m.PositiveSpans, &mm)
		case 12: // PositiveDeltas (sint64,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeSInt64(); err != nil {
					return fmt.Errorf("unable to decode sint64 value for field 'positive_deltas' (tag=12): %w", err)
				} else {
					m.PositiveDeltas = append(m.PositiveDeltas, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedSint64(); err != nil {
					return fmt.Errorf("unable to decode packed sint64 values for field 'positive_deltas' (tag=12): %w", err)
				} else {
					m.PositiveDeltas = append(m.PositiveDeltas, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'positive_deltas' (tag=12), expected 0 (varint) or 1 (length-delimited)", wt)
			}
		case 13: // PositiveCounts (double,repeated,packed)
			switch wt {
			case csproto.WireTypeFixed64:
				if v, err := dec.DecodeFloat64(); err != nil {
					return fmt.Errorf("unable to decode double value for field 'positive_counts' (tag=13): %w", err)
				} else {
					m.PositiveCounts = append(m.PositiveCounts, v)
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedFloat64(); err != nil {
					return fmt.Errorf("unable to decode packed double values for field 'positive_counts' (tag=13): %w", err)
				} else {
					m.PositiveCounts = append(m.PositiveCounts, v...)
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'positive_counts' (tag=13), expected 1 (64-bit) or 1 (length-delimited)", wt)
			}
		case 14: // ResetHint (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'reset_hint' (tag=14), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'reset_hint' (tag=14): %w", err)
			} else {
				m.ResetHint = Histogram_ResetHint(v)
			}
		case 15: // Timestamp (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timestamp' (tag=15), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'timestamp' (tag=15): %w", err)
			} else {
				m.Timestamp = v
			}

		case 1: // count.count_int (oneof,uint64)
			var ov Histogram_CountInt
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'count_int' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'count_int' (tag=1): %w", err)
			} else {
				ov.CountInt = v
			}
			m.Count = &ov
		case 2: // count.count_float (oneof,double)
			var ov Histogram_CountFloat
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'count_float' (tag=2), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'count_float' (tag=2): %w", err)
			} else {
				ov.CountFloat = v
			}
			m.Count = &ov
		case 6: // zero_count.zero_count_int (oneof,uint64)
			var ov Histogram_ZeroCountInt
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'zero_count_int' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt64(); err != nil {
				return fmt.Errorf("unable to decode uint64 value for field 'zero_count_int' (tag=6): %w", err)
			} else {
				ov.ZeroCountInt = v
			}
			m.ZeroCount = &ov
		case 7: // zero_count.zero_count_float (oneof,double)
			var ov Histogram_ZeroCountFloat
			if wt != csproto.WireTypeFixed64 {
				return fmt.Errorf("incorrect wire type %v for tag field 'zero_count_float' (tag=7), expected 1 (64-bit)", wt)
			}
			if v, err := dec.DecodeFloat64(); err != nil {
				return fmt.Errorf("unable to decode double value for field 'zero_count_float' (tag=7): %w", err)
			} else {
				ov.ZeroCountFloat = v
			}
			m.ZeroCount = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for BucketSpan

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *BucketSpan) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Offset (sint32,optional)
	if m.Offset != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfZigZag(uint64(m.Offset))
	}
	// Length (uint32,optional)
	if m.Length != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.Length))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *BucketSpan) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *BucketSpan) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Offset (1,sint32,optional)
	if m.Offset != 0 {
		enc.EncodeSInt32(1, m.Offset)
	}
	// Length (2,uint32,optional)
	if m.Length != 0 {
		enc.EncodeUInt32(2, m.Length)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *BucketSpan) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Offset (sint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'offset' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeSInt32(); err != nil {
				return fmt.Errorf("unable to decode sint32 value for field 'offset' (tag=1): %w", err)
			} else {
				m.Offset = v
			}
		case 2: // Length (uint32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'length' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeUInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'length' (tag=2): %w", err)
			} else {
				m.Length = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TimeSeries

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TimeSeries) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Labels (message,repeated)
	for _, val := range m.Labels {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Samples (message,repeated)
	for _, val := range m.Samples {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Exemplars (message,repeated)
	for _, val := range m.Exemplars {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Histograms (message,repeated)
	for _, val := range m.Histograms {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TimeSeries) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TimeSeries) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Labels (1,message,repeated)
	for _, mm := range m.Labels {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'labels' (tag=1): %w", err)
		}
	}
	// Samples (2,message,repeated)
	for _, mm := range m.Samples {
		if err = enc.EncodeNested(2, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'samples' (tag=2): %w", err)
		}
	}
	// Exemplars (3,message,repeated)
	for _, mm := range m.Exemplars {
		if err = enc.EncodeNested(3, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'exemplars' (tag=3): %w", err)
		}
	}
	// Histograms (4,message,repeated)
	for _, mm := range m.Histograms {
		if err = enc.EncodeNested(4, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'histograms' (tag=4): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TimeSeries) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Labels (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'labels' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm Label
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'labels' (tag=1): %w", err)
			}
			m.Labels = append(m.Labels, &mm)
		case 2: // Samples (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'samples' (tag=2), expected 2 (length-delimited)", wt)
			}
			var mm Sample
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'samples' (tag=2): %w", err)
			}
			m.Samples = append(m.Samples, &mm)
		case 3: // Exemplars (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'exemplars' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm Exemplar
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'exemplars' (tag=3): %w", err)
			}
			m.Exemplars = append(m.Exemplars, &mm)
		case 4: // Histograms (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'histograms' (tag=4), expected 2 (length-delimited)", wt)
			}
			var mm Histogram
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'histograms' (tag=4): %w", err)
			}
			m.Histograms = append(m.Histograms, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Label

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Label) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Value (string,optional)
	if l = len(m.Value); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Label) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Label) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Name (1,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(1, m.Name)
	}
	// Value (2,string,optional)
	if len(m.Value) > 0 {
		enc.EncodeString(2, m.Value)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Label) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=1): %w", err)
			} else {
				m.Name = s
			}

		case 2: // Value (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'value' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'value' (tag=2): %w", err)
			} else {
				m.Value = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Labels

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Labels) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Labels (message,repeated)
	for _, val := range m.Labels {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Labels) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Labels) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Labels (1,message,repeated)
	for _, mm := range m.Labels {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'labels' (tag=1): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Labels) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Labels (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'labels' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm Label
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'labels' (tag=1): %w", err)
			}
			m.Labels = append(m.Labels, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for LabelMatcher

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *LabelMatcher) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Type (enum,optional)
	if m.Type != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Type))
	}
	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Value (string,optional)
	if l = len(m.Value); l > 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *LabelMatcher) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *LabelMatcher) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Type (1,enum,optional)
	if m.Type != 0 {
		enc.EncodeInt32(1, int32(m.Type))
	}
	// Name (2,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(2, m.Name)
	}
	// Value (3,string,optional)
	if len(m.Value) > 0 {
		enc.EncodeString(3, m.Value)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *LabelMatcher) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=1): %w", err)
			} else {
				m.Type = LabelMatcher_Type(v)
			}
		case 2: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=2): %w", err)
			} else {
				m.Name = s
			}

		case 3: // Value (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'value' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'value' (tag=3): %w", err)
			} else {
				m.Value = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ReadHints

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ReadHints) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// StepMs (int64,optional)
	if m.StepMs != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.StepMs))
	}
	// Func (string,optional)
	if l = len(m.Func); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// StartMs (int64,optional)
	if m.StartMs != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.StartMs))
	}
	// EndMs (int64,optional)
	if m.EndMs != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.EndMs))
	}
	// Grouping (string,repeated)
	for _, sv := range m.Grouping {
		l = len(sv)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// By (bool,optional)
	if m.By {
		sz += csproto.SizeOfTagKey(6) + 1
	}
	// RangeMs (int64,optional)
	if m.RangeMs != 0 {
		sz += csproto.SizeOfTagKey(7) + csproto.SizeOfVarint(uint64(m.RangeMs))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ReadHints) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ReadHints) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// StepMs (1,int64,optional)
	if m.StepMs != 0 {
		enc.EncodeInt64(1, m.StepMs)
	}
	// Func (2,string,optional)
	if len(m.Func) > 0 {
		enc.EncodeString(2, m.Func)
	}
	// StartMs (3,int64,optional)
	if m.StartMs != 0 {
		enc.EncodeInt64(3, m.StartMs)
	}
	// EndMs (4,int64,optional)
	if m.EndMs != 0 {
		enc.EncodeInt64(4, m.EndMs)
	}
	// Grouping (5,string,repeated)
	for _, val := range m.Grouping {
		enc.EncodeString(5, val)
	}
	// By (6,bool,optional)
	if m.By {
		enc.EncodeBool(6, m.By)
	}
	// RangeMs (7,int64,optional)
	if m.RangeMs != 0 {
		enc.EncodeInt64(7, m.RangeMs)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ReadHints) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // StepMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'step_ms' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'step_ms' (tag=1): %w", err)
			} else {
				m.StepMs = v
			}
		case 2: // Func (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'func' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'func' (tag=2): %w", err)
			} else {
				m.Func = s
			}

		case 3: // StartMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'start_ms' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'start_ms' (tag=3): %w", err)
			} else {
				m.StartMs = v
			}
		case 4: // EndMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'end_ms' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'end_ms' (tag=4): %w", err)
			} else {
				m.EndMs = v
			}
		case 5: // Grouping (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'grouping' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'grouping' (tag=5): %w", err)
			} else {
				m.Grouping = append(m.Grouping, s)
			}

		case 6: // By (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'by' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'by' (tag=6): %w", err)
			} else {
				m.By = v
			}
		case 7: // RangeMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'range_ms' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'range_ms' (tag=7): %w", err)
			} else {
				m.RangeMs = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Chunk

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Chunk) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// MinTimeMs (int64,optional)
	if m.MinTimeMs != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.MinTimeMs))
	}
	// MaxTimeMs (int64,optional)
	if m.MaxTimeMs != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.MaxTimeMs))
	}
	// Type (enum,optional)
	if m.Type != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.Type))
	}
	// Data (bytes,optional)
	if l = len(m.Data); l > 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Chunk) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Chunk) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// MinTimeMs (1,int64,optional)
	if m.MinTimeMs != 0 {
		enc.EncodeInt64(1, m.MinTimeMs)
	}
	// MaxTimeMs (2,int64,optional)
	if m.MaxTimeMs != 0 {
		enc.EncodeInt64(2, m.MaxTimeMs)
	}
	// Type (3,enum,optional)
	if m.Type != 0 {
		enc.EncodeInt32(3, int32(m.Type))
	}
	// Data (4,bytes,optional)
	if len(m.Data) > 0 {
		enc.EncodeBytes(4, m.Data)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Chunk) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // MinTimeMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'min_time_ms' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'min_time_ms' (tag=1): %w", err)
			} else {
				m.MinTimeMs = v
			}
		case 2: // MaxTimeMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'max_time_ms' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'max_time_ms' (tag=2): %w", err)
			} else {
				m.MaxTimeMs = v
			}
		case 3: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=3): %w", err)
			} else {
				m.Type = Chunk_Encoding(v)
			}
		case 4: // Data (bytes,optional)

			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'data' (tag=4), expected 2 (length-delimited)", wt)
			}
			if b, err := dec.DecodeBytes(); err != nil {
				return fmt.Errorf("unable to decode bytes value for field 'data' (tag=4): %w", err)
			} else {
				m.Data = b
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ChunkedSeries

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ChunkedSeries) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Labels (message,repeated)
	for _, val := range m.Labels {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Chunks (message,repeated)
	for _, val := range m.Chunks {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ChunkedSeries) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ChunkedSeries) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Labels (1,message,repeated)
	for _, mm := range m.Labels {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'labels' (tag=1): %w", err)
		}
	}
	// Chunks (2,message,repeated)
	for _, mm := range m.Chunks {
		if err = enc.EncodeNested(2, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'chunks' (tag=2): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ChunkedSeries) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Labels (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'labels' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm Label
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'labels' (tag=1): %w", err)
			}
			m.Labels = append(m.Labels, &mm)
		case 2: // Chunks (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'chunks' (tag=2), expected 2 (length-delimited)", wt)
			}
			var mm Chunk
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'chunks' (tag=2): %w", err)
			}
			m.Chunks = append(m.Chunks, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
