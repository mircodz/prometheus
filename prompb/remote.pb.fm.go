// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package prompb

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for WriteRequest

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *WriteRequest) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Timeseries (message,repeated)
	for _, val := range m.Timeseries {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Metadata (message,repeated)
	for _, val := range m.Metadata {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *WriteRequest) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *WriteRequest) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Timeseries (1,message,repeated)
	for _, mm := range m.Timeseries {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'timeseries' (tag=1): %w", err)
		}
	}
	// Metadata (3,message,repeated)
	for _, mm := range m.Metadata {
		if err = enc.EncodeNested(3, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'metadata' (tag=3): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *WriteRequest) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Timeseries (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'timeseries' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm TimeSeries
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'timeseries' (tag=1): %w", err)
			}
			m.Timeseries = append(m.Timeseries, &mm)
		case 3: // Metadata (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'metadata' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm MetricMetadata
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'metadata' (tag=3): %w", err)
			}
			m.Metadata = append(m.Metadata, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ReadRequest

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ReadRequest) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Queries (message,repeated)
	for _, val := range m.Queries {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// AcceptedResponseTypes (enum,repeated,packed)
	if len(m.AcceptedResponseTypes) > 0 {
		sz += csproto.SizeOfTagKey(2)
		l = 0
		for _, iv := range m.AcceptedResponseTypes {
			l += csproto.SizeOfVarint(uint64(iv))
		}
		sz += csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ReadRequest) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ReadRequest) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Queries (1,message,repeated)
	for _, mm := range m.Queries {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'queries' (tag=1): %w", err)
		}
	}
	// AcceptedResponseTypes (2,enum,repeated,packed)
	if l := len(m.AcceptedResponseTypes); l > 0 {
		ivs := make([]int32, l)
		for i, v := range m.AcceptedResponseTypes {
			ivs[i] = int32(v)
		}
		enc.EncodePackedInt32(2, ivs)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ReadRequest) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Queries (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'queries' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm Query
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'queries' (tag=1): %w", err)
			}
			m.Queries = append(m.Queries, &mm)
		case 2: // AcceptedResponseTypes (enum,repeated,packed)
			switch wt {
			case csproto.WireTypeVarint:
				if v, err := dec.DecodeInt32(); err != nil {
					return fmt.Errorf("unable to decode int32 enum value for field 'accepted_response_types' (tag=2): %w", err)
				} else {
					m.AcceptedResponseTypes = append(m.AcceptedResponseTypes, ReadRequest_ResponseType(v))
				}
			case csproto.WireTypeLengthDelimited:
				if v, err := dec.DecodePackedInt32(); err != nil {
					return fmt.Errorf("unable to decode packed int32 enum values for field 'accepted_response_types' (tag=2): %w", err)
				} else {
					for _, elem := range v {
						m.AcceptedResponseTypes = append(m.AcceptedResponseTypes, ReadRequest_ResponseType(elem))
					}
				}
			default:
				return fmt.Errorf("incorrect wire type %v for repeated field 'accepted_response_types' (tag=2), expected 0 (varint) or 1 (length-delimited)", wt)
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ReadResponse

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ReadResponse) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Results (message,repeated)
	for _, val := range m.Results {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ReadResponse) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ReadResponse) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Results (1,message,repeated)
	for _, mm := range m.Results {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'results' (tag=1): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ReadResponse) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Results (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'results' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm QueryResult
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'results' (tag=1): %w", err)
			}
			m.Results = append(m.Results, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Query

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Query) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// StartTimestampMs (int64,optional)
	if m.StartTimestampMs != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.StartTimestampMs))
	}
	// EndTimestampMs (int64,optional)
	if m.EndTimestampMs != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.EndTimestampMs))
	}
	// Matchers (message,repeated)
	for _, val := range m.Matchers {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// Hints (message,optional)
	if m.Hints != nil {
		l = csproto.Size(m.Hints)
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Query) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Query) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// StartTimestampMs (1,int64,optional)
	if m.StartTimestampMs != 0 {
		enc.EncodeInt64(1, m.StartTimestampMs)
	}
	// EndTimestampMs (2,int64,optional)
	if m.EndTimestampMs != 0 {
		enc.EncodeInt64(2, m.EndTimestampMs)
	}
	// Matchers (3,message,repeated)
	for _, mm := range m.Matchers {
		if err = enc.EncodeNested(3, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'matchers' (tag=3): %w", err)
		}
	}
	// Hints (4,message,optional)
	if m.Hints != nil {
		if err = enc.EncodeNested(4, m.Hints); err != nil {
			return fmt.Errorf("unable to encode message data for field 'hints' (tag=4): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Query) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // StartTimestampMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'start_timestamp_ms' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'start_timestamp_ms' (tag=1): %w", err)
			} else {
				m.StartTimestampMs = v
			}
		case 2: // EndTimestampMs (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'end_timestamp_ms' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'end_timestamp_ms' (tag=2): %w", err)
			} else {
				m.EndTimestampMs = v
			}
		case 3: // Matchers (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'matchers' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm LabelMatcher
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'matchers' (tag=3): %w", err)
			}
			m.Matchers = append(m.Matchers, &mm)
		case 4: // Hints (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'hints' (tag=4), expected 2 (length-delimited)", wt)
			}
			var mm ReadHints
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'hints' (tag=4): %w", err)
			}
			m.Hints = &mm

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for QueryResult

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *QueryResult) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Timeseries (message,repeated)
	for _, val := range m.Timeseries {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *QueryResult) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *QueryResult) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Timeseries (1,message,repeated)
	for _, mm := range m.Timeseries {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'timeseries' (tag=1): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *QueryResult) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Timeseries (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'timeseries' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm TimeSeries
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'timeseries' (tag=1): %w", err)
			}
			m.Timeseries = append(m.Timeseries, &mm)

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ChunkedReadResponse

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ChunkedReadResponse) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// ChunkedSeries (message,repeated)
	for _, val := range m.ChunkedSeries {
		if l = csproto.Size(val); l > 0 {
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
		}
	}
	// QueryIndex (int64,optional)
	if m.QueryIndex != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.QueryIndex))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ChunkedReadResponse) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ChunkedReadResponse) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// ChunkedSeries (1,message,repeated)
	for _, mm := range m.ChunkedSeries {
		if err = enc.EncodeNested(1, mm); err != nil {
			return fmt.Errorf("unable to encode message data for field 'chunked_series' (tag=1): %w", err)
		}
	}
	// QueryIndex (2,int64,optional)
	if m.QueryIndex != 0 {
		enc.EncodeInt64(2, m.QueryIndex)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ChunkedReadResponse) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	// enable faster, but unsafe, string decoding
	dec.SetMode(csproto.DecoderModeFast)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // ChunkedSeries (message,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'chunked_series' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm ChunkedSeries
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'chunked_series' (tag=1): %w", err)
			}
			m.ChunkedSeries = append(m.ChunkedSeries, &mm)
		case 2: // QueryIndex (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'query_index' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'query_index' (tag=2): %w", err)
			} else {
				m.QueryIndex = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
